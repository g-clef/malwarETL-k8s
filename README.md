# malwarETL-k8s
## K8s policies/setup files for malwarETL installation

This is a set of scripts and configurations to install k8s on a local bare-metal repo, which I then run malwarETL on 
top of. 

This has a few advantages: 
  1) kubespary + ansible means that adding/removing/updating nodes is done in a scripted way, rather than manually tweaking nodes.
  2) using kubespray means it's using kubeadm under the hood, we we're still getting the recommended settings for much of the node setup.


Checklist for creating a new cluster (yes, I can automate this more...gimme time):
 - [ ] run `ansible -i lab_cluster.yml masters -m ping` and with `workers` to make sure you have the ssh keys trusted
 - [ ] run `ansible-playbook -i lab_cluster.yml site.yml` to fix a missing package in Ubuntu on raspberry PIs.
 - [ ] run `ansible-playbook -i lab_cluster.yml kubespray/cluster.yml` to install kubespray
 - [ ] grab the kubernetes config from `ansible/artifacts/admin.conf` , put it in your own ~/.kube/config, and modify the dest IP to match the IP of master-1
 - [ ] install the csi-smb driver: `helm install csi-driver-smb csi-driver-smb/csi-driver-smb --namespace kube-system --version v1.3.0`
   - [ ] you may need to add the csi-smb helm repo: `helm repo add csi-driver-smb https://raw.githubusercontent.com/kubernetes-csi/csi-driver-smb/master/charts`
 - [ ] add the daemonset and certificate secrets to handle the self-signed cert for prefect connections (part of the malwaETL-prefect repo)
 - [ ] install the prefect agent in its namespace
 - [ ] install elasticsearch via helm (see malwaretl-es for notes)
   - [ ] extract the elastic password from the installation with `kubectl get secret malwaretl-cluster-es-elastic-user -n es -o go-template='{{.data.elastic | base64decode}}'`
 - [ ] install the various malware collectors in their namespace
   - [ ] Update the collectors secrets with the ES password from above
 - [ ] install the ti-collector in its namespace
 - [ ] install the pastebin collector in its namespace
   - [ ] make sure you have a docker registry secret names "registrycreds" created to pull the private image
